# Default values for refinery.

nameOverride: ""
fullnameOverride: ""

# Values used to build the Refinery config.yaml.
# All Refinery configuration values may be supplied even if not included in this default values.yaml.
# See https://github.com/honeycombio/refinery/blob/main/config_complete.yaml for full details
# on all fields that may be configured here.
# Supports templating. To escape existing instances of {{ }}, use {{` <original content> `}}.
# For example, {{ REDACTED_EMAIL }} becomes {{` {{ REDACTED_EMAIL }} `}}.
config:
  General:
    ConfigurationVersion: 2
    MinRefineryVersion: v2.0

  Network:
    # ListenAddr is the address where Refinery listens for incoming requests.
    ListenAddr: 0.0.0.0:8080
    
    # PeerListenAddr is the IP and port on which to listen for traffic being rerouted from a peer.
    PeerListenAddr: 0.0.0.0:8081

    # HoneycombAPI is the URL of the upstream Honeycomb API where the data  will be sent.
    HoneycombAPI: https://api.honeycomb.io

  GRPCServerParameters:
    # Enabled specifies whether the gRPC server is enabled.
    Enabled: true

    # ListenAddr is the address Refinery listens to for incoming GRPC OpenTelemetry events.
    ListenAddr: 0.0.0.0:4317

    # MaxConnectionAge is the maximum amount of time a gRPC connection may exist.
    MaxConnectionAge: 3m

  Logger:
    # Type is the type of logger to use.
    Type: stdout

    # Level is the logging level above which Refinery should send a log to the logger.
    Level: warn

  Traces:
    # SendDelay is the duration to wait before sending a trace.
    SendDelay: 2s

    # BatchTimeout is how frequently Refinery sends unfulfilled batches.
    BatchTimeout: 500ms

    # TraceTimeout is the duration to wait before making the trace decision on an incomplete trace.
    TraceTimeout: 60s

    # MaxBatchSize is the maximum number of events to be included in each batch for sending.
    MaxBatchSize: 500

    # SendTicker is the interval between checks for traces to send.
    SendTicker: 100ms

  BufferSizes:
    # UpstreamBufferSize is the size of the queue used to buffer spans to send to the upstream Collector.
    UpstreamBufferSize: 10000
    
    # PeerBufferSize is the size of the queue used to buffer spans to send to peer nodes.
    PeerBufferSize: 10000

  Specialized:
    # EnvironmentCacheTTL is the duration for which environment information is cached.
    EnvironmentCacheTTL: "1h"

    # AdditionalAttributes is a map that can be used for injecting user-defined attributes into every span.
    # AdditionalAttributes:
      # ClusterName: MyCluster
      # environment: production

  Debugging:
      # AdditionalErrorFields is a list of span fields to include when logging errors happen during the ingestion of events.
      AdditionalErrorFields:
        - trace.span_id

    # QueryAuthToken is the token that must be specified to access the `/query` endpoint.
    # QueryAuthToken: "some-private-value"

  RefineryTelemetry:
    # AddRuleReasonToTrace controls whether to decorate traces with Refinery  rule evaluation results.
    AddRuleReasonToTrace: true

    # AddSpanCountToRoot controls whether to add a metadata field to root spans that indicates the number of child spans.
    AddSpanCountToRoot: true

  IDFields:
    # TraceNames is the list of field names to use for the trace ID.
    TraceNames:
      - "trace.trace_id"
      - "traceId"

    # ParentNames is the list of field names to use for the parent ID.
    ParentNames:
      - "trace.parent_id"
      - "parentId"

  PeerManagement:
    # Type is the type of peer management to use.
    Type: "redis"

    # IdentifierInterfaceName specifies a network interface to use when
    IdentifierInterfaceName: eth0

    # UseIPV6Identifier specifies that Refinery should use an IPV6 address as its identifier.
    UseIPV6Identifier: false

  RedisPeerManagement:
    # Host is the host and port of the Redis instance to use for peer cluster membership management.
    Host: '{{include "refinery.redis.fullname" .}}:6379'

    # Username is the username used to connect to Redis for peer cluster membership management.
    Username: ""

    # Password is the password used to connect to Redis for peer cluster membership management.
    Password: ""

    # Prefix is a string used as a prefix for the keys in Redis while storing the peer membership.
    Prefix: "refinery"

    # Database is the database number to use for the Redis instance storing the peer membership.
    Database: 0

    # UseTLS enables TLS when connecting to Redis for peer cluster membership management.
    UseTLS: false

  Collection:
    # CacheCapacity is the number of traces to keep in the cache's circular buffer.
    CacheCapacity: 10000

    # AvailableMemory is the amount of system memory available to the Refinery process.
    AvailableMemory: '{{ .Values.resources.limits.memory }}'

    # MaxMemoryPercentage is the maximum percentage of memory that should be allocated by the span collector.
    MaxMemoryPercentage: 75

  StressRelief:
    # Mode is a string indicating how to use Stress Relief.
    Mode: "monitor"

    # ActivationLevel is the `stress_level` (from 0-100) at which Stress Relief is triggered.
    ActivationLevel: 90

    # DeactivationLevel is the `stress_level` (from 0-100) at which Stress Relief is turned off.
    DeactivationLevel: 70

    # SamplingRate is the sampling rate to use when Stress Relief is activated.
    SamplingRate: 100

    # MinimumActivationDuration is the minimum time that Stress Relief will stay enabled once activated.
    MinimumActivationDuration: 10s

    # MinimumStartupDuration is the minimum time that Stress Relief will stay enabled.
    MinimumStartupDuration: 3s

  SampleCache:
    # KeptSize is the number of traces preserved in the cuckoo kept traces cache.
    KeptSize: 10000

    # DroppedSize is the size of the cuckoo dropped traces cache.
    DroppedSize: 1000000

    # SizeCheckInterval controls how often the cuckoo cache re-evaluates its remaining capacity.
    SizeCheckInterval: "10s"

  PrometheusMetrics:
    # Enabled controls whether to expose Refinery metrics over the `PrometheusListenAddr` port.
    Enabled: true

    # ListenAddr is the IP and port the Prometheus Metrics server will run on.
    ListenAddr: 0.0.0.0:9090

  # OTelMetrics `OTelMetrics` contains configuration for Refinery's
  # OpenTelemetry (OTel) metrics. This is the preferred way to send
  # metrics to Honeycomb. New installations should prefer `OTelMetrics`.
  OTelMetrics:
    # Enabled controls whether to send metrics via OpenTelemetry.
    enabled: false

    # APIKey is the API key used to send Honeycomb metrics via OpenTelemetry.
    APIKey: ""

# Values used to build rules.yaml
# See the example in sample-configs/rules_complete.yaml for full details on all properties
rules:
  RulesVersion: 2
  Samplers:
    # The default sampler is used when no other sampler matches.
    # It is required to have a default sampler.
    # The name consists of two underscores on either side of the word "default".
    __default__:
        DeterministicSampler:
            SampleRate: 1

  ## Dataset sampling rules ##
  # Specify dataset rules by creating an object for each dataset
  # Note: If your dataset name contains a space, you will have to escape the dataset name
  # using single quotes, such as "dataset 1":
  #
  # This example creates a sampling definition for a dataset called: test-dataset
  # test-dataset:
  #   Sampler: EMADynamicSampler
  #   GoalSampleRate: 5
  #   FieldList:
  #    - request.method
  #    - http.target
  #    - response.status_code

# RulesConfigMapName is used to override the default ConfigMap that defines the rules yaml.
# When blank, refinery is configured using the a ConfigMap based on the rules below.
# When set, refinery is configured using the rules defined in the provided ConfigMap. The ConfigMap must use rules.yaml as the key but the value can be templated.
RulesConfigMapName: ""

# LiveReload - If disabled, triggers a rolling restart of the cluster whenever
# the Rules configmap changes
LiveReload: true

## Scaling Refinery ##
#
# Since Refinery is a stateful service we recommend provisioning refinery 
# for your anticipated peak load and using Stress Relief to minimize impact
# from changes in cluster membership.
#
# Use replicaCount and resource limits to set the size of your Refinery cluster
# per your anticipated peak load.
# replicaCount is ignored if autoscaling is enabled
replicaCount: 3

resources:
  limits:
    cpu: 2000m
    # This value is used by default for config.Collection.AvailableMemory
    memory: 2Gi
  requests:
    cpu: 500m
    memory: 500Mi

nodeSelector: {}

tolerations: []

affinity: {}

# Setup autoscaling for refinery
# When autoscaling events occur, trace sharding will be recomputed. This will result in traces with missing spans being
# sent to Honeycomb, for a small period of time (approximately config.Traces.TraceTimeout * 2).
# Because of this, scaleDown is disabled by default to avoid unnecessary broken traces should traffic go up and down rapidly.
autoscaling:
  enabled: false
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 75
  # targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      selectPolicy: Disabled

image:
  repository: honeycombio/refinery
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: [ ]

# Use to pass in additional environment variables into Refinery
# Refinery supports environment variables for some configuration options such as:
# - Honeycomb API Key used by Logger and Metrics: REFINERY_HONEYCOMB_API_KEY
# - gRPC listen address: REFINERY_GRPC_LISTEN_ADDRESS
# - Redis Host: REFINERY_REDIS_HOST
# - Redis Username: REFINERY_REDIS_USERNAME
# - Redis Password: REFINERY_REDIS_PASSWORD
environment: [ ]
  # - name: REFINERY_HONEYCOMB_API_KEY
  #   valueFrom:
  #     secretKeyRef:
  #       name: honeycomb
  #       key: api-key

# Use to map additional volumes into the Refinery pods
# Useful for volume-based secrets
extraVolumeMounts: [ ]
  # - name: honeycomb-secrets
  #   mountPath: "/mnt/secrets-store"
  #   readOnly: true

# Use to map additional volumes into the Refinery pods
extraVolumes: [ ]
  # - name: honeycomb-secrets
  #   csi:
  #     driver: secrets-store.csi.k8s.io
  #     readOnly: true
  #     volumeAttributes:
  #       secretProviderClass: "honeycomb-secrets"

# Redis configuration
redis:

  # To install a simple single pod Redis deployment set this to true.
  # If false, you must specify a value for existingHost
  # For production, it is recommended to set this to false and provide
  # a highly available Redis configuration using redis.existingHost
  enabled: true

  # If redis.enabled is false this needs to be specified.
  # This needs to be the name:port of a Redis configuration
  # existingHost:

  # If redis.enabled is true, this the image that will be used to create
  # the Redis deployment
  image:
    repository: redis
    tag: 6.2.5
    pullPolicy: IfNotPresent

  # Node selector specific to installed Redis configuration. Requires redis.enabled to be true
  nodeSelector: {}

  # Tolerations specific to installed Redis configuration. Requires redis.enabled to be true
  tolerations: []

  # Affinity specific to installed Redis configuration. Requires redis.enabled to be true
  affinity: {}
  annotations: {}

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  labels: {}
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podLabels: {}

podAnnotations: {}

deploymentAnnotations: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP
  port: 80
  grpcPort: 4317
  labels: {}
  annotations: {}

ingress:
  enabled: false
  labels: {}
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: refinery.local
      path: /
  tls: []
  #  - secretName: refinery-tls
  #    hosts:
  #      - refinery.local

grpcIngress:
  enabled: false
  labels: {}
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: refinery.local
      path: /
  tls: []
  #  - secretName: refinery-tls
  #    hosts:
  #      - refinery.local

# If you need to create a secret provider, such as for using AWS SSM, you can do so here.
# secretProvider functionality requires the Secret Store CSI Driver:
# https://secrets-store-csi-driver.sigs.k8s.io/
#
# secretProvider:
#   create: true
#   spec:
#     provider: aws
#     secretObjects:
#     - secretName: refinery
#       type: Opaque
#       data:
#         - key: yourenvironment.refinery_honeycomb_api_key
#           objectName: youenvironment.refinery_honeycomb_api_key
#     parameters:
#       objects: |
#           - objectName: yourenvironment.refinery_honeycomb_api_key
#             objectType: "ssmparameter"
#   name: "refinery"

secretProvider:
  create: false
  name: refinery
  spec: {}

# When enabled, adds the -d flag to Refinery's arguments which enables the debug service.
debug: 
  enabled: false
  # The port on which Refinery exposes the debug service.
  # Only used if debug is enabled.
  # This value will be used to set config.DebugServiceAddr if it is not already set.
  port: 6060
